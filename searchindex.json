{"categories":[{"title":"accessibility","uri":"https://bernd.dev/categories/accessibility/"},{"title":"cloud computing","uri":"https://bernd.dev/categories/cloud-computing/"},{"title":"productivity","uri":"https://bernd.dev/categories/productivity/"},{"title":"security","uri":"https://bernd.dev/categories/security/"},{"title":"troubleshooting","uri":"https://bernd.dev/categories/troubleshooting/"}],"posts":[{"content":"Perhaps you\u0026rsquo;ve seen vulnerability reports in your CI/CD pipeline or tools like NPM. Cloud infrastructure has these too and I was surprised to get an alert. Naturally, I had to investigate to see where I went wrong\u0026hellip; (and of course mitigate the problem).\nThe security alert It all started a few weeks ago when I received an email from a colleague with the following content.\nSecure transfer to storage accounts should be enabled\nSubscription ID: devrel-berndverst-demo-test\nResource: /subscriptions/XXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXXX/ resourcegroups/kubeflowrelease/providers/ microsoft.storage/storageaccounts/ \u0026gt; fairingXXXXXXXXXXXXXXXXX\n1-Click mitigation link\nNote: several similar results have been omitted\n This was my gut reaction:\n üò±This cannot be. What did I do wrong? Did I mess something up? üò∞\n My colleague had used Azure Security Center to generate a report of security issues. Since I had never received such a message before (note I could have set up email alerts in Azure Security Center myself) I was a bit skeptical and first verified the authenticity of the email: Email domain, Sender Police Framework (SPF) check, Domain Keys Identified Mail (DKIM) all indicated the email was legitimate.\nThe 1-Click mitigation link (which I verified went to the Azure web portal domain) took me directly to the recommendations section in the Azure Security Center for my Azure account and jumped to the relevant entries. The Security Center recommendations documentation also had more information on the alert I had received.\nWhat I did wrong (supposedly) Azure Blob Storage accounts should be configured to only serve traffic over https.\n The 1-step mitigation in Azure Security Center resolved the issue, but I could also have followed these instructions in the docs.\n ü§î Why would I ever not want secure blob transfers? This does not sound like me.\n Taking a closer look I noticed that all affected blob storage accounts had programmatically generated names. Furthermore they all resided in my Azure resource group kubeflowrelease and contained the string fairing in the account names.\nDays earlier I had ported an end to end tutorial for Kubeflow using the MNIST training set to Azure. Of course in the process I deployed Kubeflow to my Kubernetes cluster and went through the tutorial I wrote.\nThe Kubeflow project is dedicated to making deployments of machine learning (ML) workflows on Kubernetes simple, portable and scalable.\n The culprit: Kubeflow  üí°Kubeflow somehow created the storage accounts in question\n The Kubeflow Fairing helper library created the storage account without forcing secure transport.\nHow to correctly create secure storage accounts Looking at the relevant documentation I discovered something very interesting:\nBy default, the Secure transfer required property is enabled when you create a storage account in Azure portal. However, it is disabled when you create a storage account with SDK.\n In other words, the SDKs default to doing that for which the Azure Security Center alerted me, creating insecure storage accounts.\n ‚ùìKubeflow Fairing is written in Python. I wonder how to create secure storage accounts with the Azure Python SDK.\n The Python SDK sample code at github.com/Azure-Samples/storage-python-manage does not explicitly set the secure option. The sample code uses the insecure default [Edit: it turns out that this depends on the SDK version used]. I made this pull request to fix this.\n Fixing the sample code led to several unrelated issues with the tests, all of which I fixed:\n The Azure Python SDK version was not locked and the API output had changed, no longer matching the mocked responses Travis was running tests for a version of Python that was no longer supported Travis was not running tests for current versions of Python 3.7 and 3.8.  It took me hours, but Azure-Samples/storage-python-manage#11 fixed all of the above.\nWhat did Kubeflow Fairing do? Taking a close look we can see that Kubeflow Fairing basically copied from the Azure Python sample code.\n I would have done the same. Good thing that is fixed now!\n I made this pull request to fix the issue in Kubeflow Fairing.\n Success?  ‚úÖ Kubeflow Fairing now creates secure storage accounts. ‚úÖ Anyone finding the Azure Python SDK samples for storage account creation will create secure accounts. \n Solution:\nA new version of the Azure Storage Resource Provider API should default to creating secure storage accounts if the supportsHttpsTrafficOnly parameter has not been provided.\n Anyone who updates the Azure CLI or Storage SDK will automatically inherit secure defaults. Those who have been relying on the insecure behavior (this should be few people) will experience a breaking change, but they of course are not required to upgrade SDKs or API versions and can certainly explicitly set the parameter.\nExactly what I suggested here was indeed done since API version 2019-04-01. All current SDKs will be using this API version or a newer one which defaults to the secure setting.\n So why the Kubeflow Fairing issue afterall? Kubeflow Fairing was using the deprecated azure library. Instead azure-mgmt-storage should have been used.\n The edits to the Azure Python sample documentation weren\u0026rsquo;t strictly necessary. But at least I fixed the tests.\n","id":0,"section":"posts","summary":"\u003cp\u003ePerhaps you\u0026rsquo;ve seen vulnerability reports in your CI/CD pipeline or tools like NPM. Cloud infrastructure has these too and I was surprised to get an alert. Naturally, I had to investigate to see where I went wrong\u0026hellip; (and of course mitigate the problem).\u003c/p\u003e","tags":["azure","kubernetes","kubeflow","open source"],"title":"From Cloud Security Alert to Open Source Bugfix","uri":"https://bernd.dev/2020/04/from-security-alert-to-bugfix/","year":"2020"},{"content":"Is your video too long for upload to Twitter or Instagram? Do you want to export just a specific clip? Using video editors to trim videos requires reencoding the entire video. Instead I will show you how to instantly trim your videos and even maintain embedded subtitle tracks.\nBackground A few days ago I created a post on easily adding subtitles to your videos. Today I wanted to verify that Twitter correctly shows these subtitles, but I discovered that my video was too long. Having played with FFmpeg I suspected that there may be a more efficient way for trimming videos than using a video editor. Be prepared to have your mind blown! ü§Ø\nRequirements FFmpeg You will need the open-source FFmpeg tool.\n FFmpeg is the leading multimedia framework, able to decode, encode, transcode, mux, demux, stream, filter and play pretty much anything that humans and machines have created.\n Please follow the installation instructions here. On Mac, simply use Homebrew with brew install ffmpeg\nInstantly trim videos The following command reads the source video and copies all streams contained within (video, audio, subtitles) to the output. The various time parameters ensure only a specific part of the original video is written to the output. The video and audio streams are not reencoded. The time required for reencoding would directly depend on the duration of the video, however we are simply copying parts of the video. For this reason the following operation is near instant. A huge time saving over workflows involving video editors.\nINFILE=\u0026quot;video.mp4\u0026quot; OUTFILE=\u0026quot;shortenedclip.mp4\u0026quot; START=\u0026quot;00:00:12.35\u0026quot; # Start Time in hh:mm:ss.msec format DURATION=\u0026quot;00:01:05.4\u0026quot; # Duration in hh:mm:ss.msec format ################## Alternative format ################## # START=\u0026quot;12.35\u0026quot; # Start time in s.msec format # # DURATION=\u0026quot;65.4\u0026quot; # Duration time in s.msec format # ######################################################## ffmpeg -ss $START -i $INFILE -c copy -map 0 -t $DURATION $OUTFILE # If you prefer you can also specify an end time similar to the start time END=\u0026quot;00:01:12.75\u0026quot; ffmpeg -ss $START -i $INFILE -c copy -map 0 -to $END $OUTFILE  ","id":1,"section":"posts","summary":"\u003cp\u003eIs your video too long for upload to Twitter or Instagram? Do you want to export just a specific clip? Using video editors to trim videos requires reencoding the entire video. Instead I will show you how to \u003cstrong\u003einstantly\u003c/strong\u003e trim your videos and even maintain embedded subtitle tracks.\u003c/p\u003e","tags":["video","ffmpeg","bash","productivity"],"title":"Trim Videos Instantly","uri":"https://bernd.dev/2020/04/trim-videos-instantly/","year":"2020"},{"content":"For accessibility reasons all video content you create should be captioned, but adding subtitles can be a daunting task. In this article we cover how to quickly and easily add subtitles to your existing videos without any video editing software.\nRequirements Inputs Video Format: This approach will only work for MP4 videos. Both H.264 and H.265/HEVC are supported.\nCaption / Subtitle file: Either SRT or WebVTT format are supported. Don\u0026rsquo;t have a caption file? See instructions below.\nFFmpeg The instructions rely on the open-source FFmpeg tool.\n FFmpeg is the leading multimedia framework, able to decode, encode, transcode, mux, demux, stream, filter and play pretty much anything that humans and machines have created.\n Please follow the installation instructions here. On Mac, simply use Homebrew with brew install ffmpeg\nCreating a caption file automatically (optional) If you do not have a captions file with subtitles for your video you can easily auto-caption your video with one of two methods.\n Upload your video to YouTube. YouTube can automatically caption your video. Captions can be downloaded in SRT file format. If your company has Microsoft Stream, upload your video to enjoy auto-captioning. Once the captions have been generated you can easily make edits through the web interface before downloading your captions in WebVTT format.  Making subtitles selectable These subtitles can be toggled on or off in any video player that supports subtitles.\n# Replace with your input video and subtitle file INFILE=video.mp4 SUBTITLES=subtitles.vtt ffmpeg -i $INFILE -i $SUBTITLES -c copy -c:s mov_text \\ -metadata:s:s:0 language=eng outfile_selectable.mp4  Multiple languages You can even have multiple subtitles in different languages all within the same video.\n# Replace with your input video and subtitle files INFILE=video.mp4 SUBTITLESENG=english.vtt SUBTITLEGER=german.vtt SUBTITLESSPA=spanish.vtt ffmpeg -i $INFILE -i $SUBTITLESENG -i $SUBTITLESGER -i $SUBTITLESSPA \\ -map 0 -map 1:s -map 2:s -map 3:s -c copy -c:s mov_text -c:s mov_text c:s mov_text \\ -metadata:s:s:0 language=eng -metadata:s:s:1 language=ger \\ -metadata:s:s:2 language=spa outfile_selectable_multi.mp4  Burned in subtitles These subtitles are part of the video itself and cannot be toggled off.\nWe will need to render the video again with the subtitles permanently added into the video stream. Note that this will take some time depending on the video duration, quality and the quality of your CPU and GPU.\nTradeoff: While hardware accelerated encoding using GPUs is generally significantly faster, software encoding (CPU only) produces smaller files and better quality.\nTradeoff: H.264 has the most compatibility. You likely have hardware support for encoding and decoding. H.265/HEVC files are 25-50% more efficient but decoding is much more compute intensive. Only recent GPUs have hardware support for encoding in this format. Nevertheless, H.265/HEVC is the format of the future.\nFor output in H.264 with hardware encoding on MacOS\n# Replace with your input video and subtitle file INFILE=video.mp4 SUBTITLES=subtitles.vtt ffmpeg -i $SUBTITLES temp.ass \u0026amp;\u0026amp; \\ BITRATE=$(ffprobe -v error -select_streams v:0 -show_entries stream=bit_rate \\ -of default=noprint_wrappers=1:nokey=1 $INFILE) \u0026amp;\u0026amp; \\ ffmpeg -i $INFILE -vf ass=temp.ass -vcodec h264_videotoolbox \\ -b:v $BITRATE -c:a copy output_burnedin.mp4  For H.264 with hardware encoding on Windows/Linux with NVIDIA GPU\n# Replace with your input video and subtitle file INFILE=video.mp4 SUBTITLES=subtitles.vtt ffmpeg -i $SUBTITLES temp.ass \u0026amp;\u0026amp; \\ BITRATE=$(ffprobe -v error -select_streams v:0 -show_entries stream=bit_rate \\ -of default=noprint_wrappers=1:nokey=1 $INFILE) \u0026amp;\u0026amp; \\ ffmpeg -i $INFILE -vf ass=temp.ass -vcodec h264_nvenc \\ -b:v $BITRATE -c:a copy output_burnedin.mp4  For H.264 with software encoding on any operating system\n# Replace with your input video and subtitle file INFILE=video.mp4 SUBTITLES=subtitles.vtt ffmpeg -i $SUBTITLES temp.ass \u0026amp;\u0026amp; \\ BITRATE=$(ffprobe -v error -select_streams v:0 -show_entries stream=bit_rate \\ -of default=noprint_wrappers=1:nokey=1 $INFILE) \u0026amp;\u0026amp; \\ ffmpeg -i $INFILE -vf ass=temp.ass -vcodec libx264 \\ -b:v $BITRATE -c:a copy output_burnedin.mp4  For H.265/HEVC with hardware encoding on MacOS\n# Replace with your input video and subtitle file INFILE=video.mp4 SUBTITLES=subtitles.vtt ffmpeg -i $SUBTITLES temp.ass \u0026amp;\u0026amp; \\ BITRATE=$(ffprobe -v error -select_streams v:0 -show_entries stream=bit_rate \\ -of default=noprint_wrappers=1:nokey=1 $INFILE) \u0026amp;\u0026amp; \\ ffmpeg -i $INFILE -vcodec hevc_videotoolbox -tag:v hvc1 \\ -b:v $BITRATE -c:a copy -vf ass=temp.ass output_burnedin.mp4  For H.265/HEVC with hardware encoding on Windows/Linux with NVIDIA GPU\n# Replace with your input video and subtitle file INFILE=video.mp4 SUBTITLES=subtitles.vtt ffmpeg -i $SUBTITLES temp.ass \u0026amp;\u0026amp; \\ BITRATE=$(ffprobe -v error -select_streams v:0 -show_entries stream=bit_rate \\ -of default=noprint_wrappers=1:nokey=1 $INFILE) \u0026amp;\u0026amp; \\ ffmpeg -i $INFILE -vcodec hevc_nvenc -tag:v hvc1 \\ -b:v $BITRATE -c:a copy -vf ass=temp.ass output_burnedin.mp4  For H.265/HEVC software encoding on any operating system\n# Replace with your input video and subtitle file INFILE=video.mp4 SUBTITLES=subtitles.vtt ffmpeg -i $SUBTITLES temp.ass \u0026amp;\u0026amp; \\ BITRATE=$(ffprobe -v error -select_streams v:0 -show_entries stream=bit_rate \\ -of default=noprint_wrappers=1:nokey=1 $INFILE) \u0026amp;\u0026amp; \\ ffmpeg -i $INFILE -vcodec libx265 -tag:v hvc1 \\ -b:v $BITRATE -c:a copy -vf ass=temp.ass output_burnedin.mp4  Note: If the source video was in H.264 format you can also use the H.265 command to produce a final video in H.265/HEVC format. Since H.265 is 25-50% more efficient you should be able to reduce the Bitrate and still maintain the same video quality.\n","id":2,"section":"posts","summary":"\u003cp\u003eFor accessibility reasons all video content you create should be captioned, but adding subtitles can be a daunting task. In this article we cover how to quickly and easily add subtitles to your existing videos without any video editing software.\u003c/p\u003e","tags":["video","ffmpeg","bash","accessibility"],"title":"Adding subtitles to your videos the easy way","uri":"https://bernd.dev/2020/04/adding-subtitles/","year":"2020"}],"tags":[{"title":"accessibility","uri":"https://bernd.dev/tags/accessibility/"},{"title":"azure","uri":"https://bernd.dev/tags/azure/"},{"title":"bash","uri":"https://bernd.dev/tags/bash/"},{"title":"ffmpeg","uri":"https://bernd.dev/tags/ffmpeg/"},{"title":"index","uri":"https://bernd.dev/tags/index/"},{"title":"kubeflow","uri":"https://bernd.dev/tags/kubeflow/"},{"title":"kubernetes","uri":"https://bernd.dev/tags/kubernetes/"},{"title":"open source","uri":"https://bernd.dev/tags/open-source/"},{"title":"productivity","uri":"https://bernd.dev/tags/productivity/"},{"title":"video","uri":"https://bernd.dev/tags/video/"}]}